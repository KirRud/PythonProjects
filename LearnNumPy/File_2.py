from numpy import *

a = array([(1, 2), (1, 2)])
b = array([(1, 1), (2, 3)])
# print(a)
# print(b)
# Умножение
c = a * b
d = dot(a, b)  # умножение матриц
# print(c)
# print("-"*25)
# print(d)

a = array([1, 2])
b = array([3, 2])
d = dot(a, b)
# print("-"*25)
# print(d) # не выполняются обычные правила, те не обязательно чтобы матрицы были размерности (n,m) и (m,k)

# рандомирование матрицы
a = random.random((10, 30))
# print(a)

# При работе с массивами разных типов, тип результирующего массива соответствует более общему или более точному типу.
a = ones(3, dtype=int32)
# print(a)
b = linspace(0, pi, 3)
# print(b)
# print(b.dtype)
c = a + b
# print(c.dtype)
d = exp(c * 1j)
# print(d)
# print(d.dtype)

# Sum Min max
a = random.normal(1, 10, size=(2, 5))  # в блоке random множество различных ф-й, кот -ые генерируют случ числа или число
# print(a)
# print(a.sum())
# print(a.min())
# print(a.max())
# с помощью  axis можно применить операцию по указанной оси массива:
# print(a.max(axis=0)) # max в каждом столбце
# print(a.sum(axis=1)) # sum в каждой строке

# УНИВЕРСАЛЬНЫЕ Ф-ИЕ
a = array([0, 1, 2, 4])
b = ones(4, dtype=int32)
# print(exp(a))
# print(sqrt(a))
# print(add(a,b))

# ИНДЕКСЫ, СРЕЗЫ, ИТЕРАЦИИ
# одномерные
A = arange(10) ** 3
# print(A)
# print(A[3:8:3])  # 1 -начало интервала 2 - конец интервала 3 - шаг
# print(A[::-1])  # перевернуть
# A[1::2]=100
# for i in A:
#     print(i ** (1 / 3.))


# многомерные
# У многомерных массивов на каждую ось приходится один индекс.
# Индексы передаются в виде последовательности чисел, разделенных запятыми:
def f(x, y):
    return 10 * x + y


b = fromfunction(f, (5, 4), dtype=int)
# print(b)
# print(b[2,3])
# print(b[:,1])# второй столбец массива
# print(b[1:3:,])# вторая и третья строки массива
# print(b[-1])# последняя строка. Эквивалентно b[-1,:]
# print(b[-2,:])
# print(b[0:2:,0]) # но нельзя print(b[0:2:0,])

# Однако, если нужно перебрать поэлементно весь массив,
# как если бы он был одномерным, для этого можно использовать атрибут flat:
# for element in b.flat:
#     print(element)

# Манипуляции с формой
a = floor(10*random.random((3,4))) #floor отбрасывает дробную часть
# print(a)
# Форма массива может быть изменена с помощью различных команд:
c = a.ravel()# делает массив плоским по идее
# print(c)
d = transpose(a)# транспонирование
# print(d)

# Функция reshape() возвращает ее аргумент с измененной формой, в то время как метод resize() изменяет сам массив:
b = array([(7,5),(9,3),(7,2),(7,8),(6,8),(3,2)])
# print(b)
a = resize(b,(2,6))
# print(a)
a = resize(b,(3,3))
# print(a)
a = resize(b,(3,6))# если размер больше изначального не достающие элементы он берет начиная с начала массив
# print(a)
a = reshape(b,(2,6))
# print(a)
# a = reshape(b,(3,6))# в случае reshape если размерность массива больше он выдает ошибку
# a = reshape(b,(3,3))# в случае если меньше тоже самое
# те с помощью reshape можно изменить размер массива но кол-во элементов должно остаться таким же: не больше, не меньше

# Если при операции такой перестройки один из аргументов задается как -1,
# то он автоматически рассчитывается в соответствии с остальными заданными:
a = reshape(b,(3,-1))
# print(a)

a = floor(10*random.random((3,2)))
b = floor(10*random.random((3,2)))
print(a)
print(b)
print("-"*25)
# разных размеров не объединяет
c = vstack((a,b))# формирует массив 6 * 2(те объединяется содержимое столбцов)
d = hstack((a,b))# формирует массив 3 * 4(те объединяется содержимое строк)
print(c)
print("-"*25)
print(d)